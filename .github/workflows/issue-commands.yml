name: Issue Command Automation

on:
  issue_comment:
    types: [created]

permissions:
  issues: write

jobs:
  handle-issue-commands:
    runs-on: ubuntu-latest
    steps:
      - name: Parse and handle issue commands
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body.trim();
            const actor = context.payload.sender.login;
            const issue_number = context.payload.issue.number;
            const repo_owner = context.repo.owner;
            const repo_name = context.repo.repo;
            const issue_labels = context.payload.issue.labels.map(l => l.name);

            // Config variables
            const FRONTEND_TEAM = (process.env.FRONTEND_TEAM || '').split(',').map(u => u.trim()).filter(Boolean);
            const BACKEND_TEAM = (process.env.BACKEND_TEAM || '').split(',').map(u => u.trim()).filter(Boolean);
            const ASSIGN_ALLOWLIST = (process.env.ASSIGN_ALLOWLIST || '').split(',').map(u => u.trim()).filter(Boolean);

            // Command parsing
            const assignMatch = comment.match(/^\/assign(?:\s+@?(\w[\w-]+))?$/);
            const unassignMatch = comment.match(/^\/unassign(?:\s+@?(\w[\w-]+))?$/);
            if (!assignMatch && !unassignMatch) return;

            // Blocked labels
            const blockedLabels = ['blocked', 'do-not-assign', 'needs-triage'];
            if (issue_labels.some(l => blockedLabels.includes(l))) {
              await github.rest.issues.createComment({
                issue_number,
                owner: repo_owner,
                repo: repo_name,
                body: 'Cannot assign: blocked label present.'
              });
              return;
            }

            // Assignment rules
            const allowedLabels = ['ready', 'help wanted', 'good first issue', 'available'];
            const restrictedLabels = ['security', 'private'];
            const frontendLabel = 'frontend';
            const backendLabel = 'backend';

            // Helper: check org membership
            async function isOrgMember(username) {
              try {
                const res = await github.rest.orgs.checkMembershipForUser({
                  org: repo_owner,
                  username
                });
                return res.status === 204;
              } catch (e) {
                return false;
              }
            }

            // Helper: check collaborator
            async function isCollaborator(username) {
              try {
                const res = await github.rest.repos.checkCollaborator({
                  owner: repo_owner,
                  repo: repo_name,
                  username
                });
                return res.status === 204;
              } catch (e) {
                return false;
              }
            }

            // Determine target user
            let targetUser = actor;
            if (assignMatch && assignMatch[1]) targetUser = assignMatch[1];
            if (unassignMatch && unassignMatch[1]) targetUser = unassignMatch[1];

            // Assignment restrictions
            if (assignMatch) {
              // Only allow self-assignment if allowed label present
              if (targetUser === actor && !issue_labels.some(l => allowedLabels.includes(l))) {
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: 'Cannot self-assign until label help wanted, ready, available, or good first issue is applied.'
                });
                return;
              }
              // Restricted labels
              if (issue_labels.some(l => restrictedLabels.includes(l))) {
                if (!ASSIGN_ALLOWLIST.includes(targetUser)) {
                  const isMember = await isOrgMember(targetUser);
                  const isCollab = await isCollaborator(targetUser);
                  if (!isMember && !isCollab) {
                    await github.rest.issues.createComment({
                      issue_number,
                      owner: repo_owner,
                      repo: repo_name,
                      body: 'Assignment restricted: only org members, collaborators, or allowlisted users may be assigned.'
                    });
                    return;
                  }
                }
              }
              // Frontend label
              if (issue_labels.includes(frontendLabel) && !FRONTEND_TEAM.includes(targetUser)) {
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: 'Assignment restricted: only frontend team members may be assigned.'
                });
                return;
              }
              // Backend label
              if (issue_labels.includes(backendLabel) && !BACKEND_TEAM.includes(targetUser)) {
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: 'Assignment restricted: only backend team members may be assigned.'
                });
                return;
              }
              // Already assigned?
              const assignees = context.payload.issue.assignees.map(a => a.login);
              if (assignees.includes(targetUser)) {
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: `Already assigned to @${targetUser}.`
                });
                return;
              }
              // Assign
              try {
                await github.rest.issues.addAssignees({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  assignees: [targetUser]
                });
                await github.rest.reactions.createForIssueComment({
                  comment_id: context.payload.comment.id,
                  owner: repo_owner,
                  repo: repo_name,
                  content: 'rocket'
                });
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: `Assigned to @${targetUser}.`
                });
              } catch (e) {
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: `Assignment failed: ${e.message}`
                });
              }
              return;
            }

            // Unassign
            if (unassignMatch) {
              const assignees = context.payload.issue.assignees.map(a => a.login);
              if (!assignees.includes(targetUser)) {
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: `@${targetUser} is not assigned.`
                });
                return;
              }
              try {
                await github.rest.issues.removeAssignees({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  assignees: [targetUser]
                });
                await github.rest.reactions.createForIssueComment({
                  comment_id: context.payload.comment.id,
                  owner: repo_owner,
                  repo: repo_name,
                  content: 'eyes'
                });
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: `Unassigned @${targetUser}.`
                });
              } catch (e) {
                await github.rest.issues.createComment({
                  issue_number,
                  owner: repo_owner,
                  repo: repo_name,
                  body: `Unassignment failed: ${e.message}`
                });
              }
            }
        env:
          FRONTEND_TEAM: ${{ vars.FRONTEND_TEAM }}
          BACKEND_TEAM: ${{ vars.BACKEND_TEAM }}
          ASSIGN_ALLOWLIST: ${{ vars.ASSIGN_ALLOWLIST }}
